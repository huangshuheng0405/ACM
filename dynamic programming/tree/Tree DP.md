# 树形DP

通常，树形DP一般都为当前结点的最优解，先DFS遍历子树的所有最优解，然后**向上传递**给子树的父节点来转移，最终根节点的值为所求的最优解

# 没有上司的舞会

## 题目描述

某大学有 $n$ 个职员，编号为 $1\ldots n$。

他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。

现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。

所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。

## 输入格式

输入的第一行是一个整数 $n$。

第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i+1)$ 行的整数表示 $i$ 号职员的快乐指数 $r_i$。

第 $(n + 2)$ 到第 $2n$ 行，每行输入一对整数 $l, k$，代表 $k$ 是 $l$ 的直接上司。

## 输出格式

输出一行一个整数代表最大的快乐指数。

## 样例 #1

### 样例输入 #1

```
7
1
1
1
1
1
1
1
1 3
2 3
6 4
7 4
4 5
3 5
```

### 样例输出 #1

```
5
```

## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\leq n \leq 6 \times 10^3$，$-128 \leq r_i\leq 127$，$1 \leq l, k \leq n$，且给出的关系一定是一棵树。

# solve

$dp[u][1]$表示u节点参加舞会，那么它的上司就不能来参加舞会了

$dp[u][0]$表示u节点不参加舞会那么，它的上司可以来也可以不来

先找到根节点

深搜到叶子节点后，返回父节点是进行选择$dp[u][0] += max(dp[v][0], dp[v][1])$，

$dp[u][1] += dp[v][0]$，如果父节点参加舞会那么子节点就不能来参加了

```c++
#include <bits/stdc++.h>

using i64 = long long;

void solve() {
    int n;
    std::cin >> n;
    std::vector<int> a(n + 1), fa(n + 1);
    std::vector<std::vector<int>> adj(n + 1);
    for (int i = 1; i <= n; i++) {
        std::cin >> a[i];
    }
    for (int i = 1; i < n; i++) {
        int u, v;
        std::cin >> u >> v;
        adj[v].push_back(u);//v是u的父节点
        fa[u] = v;
    }
    int root = 1;
    while (fa[root]) {// 找到父节点
        root++;
    }
    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(2));
    auto dfs = [&](auto &&self, int u) -> void {
        dp[u][1] = a[u];
        for (auto v : adj[u]) {
            self(self, v);
            dp[u][0] += std::max(dp[v][0], dp[v][1]);
            dp[u][1] += dp[v][0];
        }
    };
    dfs(dfs, root);
    std::cout << std::max(dp[root][1], dp[root][0]) << "\n";
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    int _ = 1;

    // cin >> _;
    while (_--) {
        solve();
    }
    return 0;
}
```

# P8744 [蓝桥杯 2021 省 A] 左孩子右兄弟

## 题目描述

对于一棵多叉树，我们可以通过“左孩子右兄弟”表示法，将其转化成一棵二叉树。

如果我们认为每个结点的子结点是无序的，那么得到的二叉树可能不唯一。换句话说，每个结点可以选任意子结点作为左孩子，并按任意顺序连接右兄弟。

给定一棵包含 $N$ 个结点的多叉树，结点从 $1$ 至 $N$ 编号，其中 $1$ 号结点是根，每个结点的父结点的编号比自己的编号小。请你计算其通过"左孩子右兄弟"表示法转化成的二叉树，高度最高是多少。（只有根结点这一个结点的树高度为 $0$）

例如如下的多叉树：

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_d8f144a59f4c0ce9322ag-11.jpg)

可能有以下 $3$ 种 (这里只列出 $3$ 种, 并不是全部) 不同的 “左孩子右兄弟” 表示: 

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_d8f144a59f4c0ce9322ag-12.jpg)

其中最后一种高度最高, 为 $4$。

## 输入格式

输入的第一行包含一个整数 $N$ 。

以下 $N-1$ 行, 每行包含一个整数, 依次表示 $2$ 至 $N$ 号结点的父结点编号。

## 输出格式

输出一个整数表示答案。

## 输入输出样例 #1

### 输入 #1

```
5
1
1
1
2
```

### 输出 #1

```
4
```

## 说明/提示

对于 $30 \%$ 的评测用例，$1 \leq N \leq 20$;

对于所有评测用例，$1 \leq N \leq 10^5$ 。 

蓝桥杯 2021 第一轮省赛 A 组 H 题。

# 题解

尽量把儿子多的子树展开放到主链上，这样子树对高度增加的贡献等于儿子数量

$f[u]$表示子树$u$转化后的最大高度，$son[u]$存储节点$u$的儿子数

每次回溯到$u$点，更新$f[u]=max(f[u],f[v])$

最后回溯时，再累加$u$的儿子的贡献$f[u]+=son[u]$

最后答案就是$f[1]$

```c++
#include <bits/stdc++.h>
using namespace std;

using i64 = long long;

void solve() {
    int n;
    cin >> n;
    struct Edge {
        int to, ne;
    };
    vector<Edge> adj(n << 1 + 1);
    vector<int> son(n + 1), dp(n + 1), h(n + 1);
    int cur = 0;
    auto add = [&](int u, int v) {
        adj[++cur] = {v, h[u]};
        h[u] = cur;
    };
    for (int i = 2; i <= n; i++) {
        int u;
        cin >> u;
        add(u, i);
        son[u]++;//u的儿子数+1
    }
    auto dfs = [&](auto &&self, int u) -> void {
        for (int i = h[u]; i; i = adj[i].ne) {
            int v = adj[i].to;
            self(self, v);
            dp[u] = max(dp[u], dp[v]);
        }
        dp[u] += son[u];
    };
    dfs(dfs, 1);
    cout << dp[1] << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int _ = 1;

    // cin >> _;
    while (_--) {
        solve();
    }
    return 0;
}
```

# P8677 [蓝桥杯 2018 国 A] 采油

## 题目描述

LQ 公司是世界著名的石油公司，为世界供应优质石油。

最近，LQ 公司又在森林里发现了一大片区域的油田，可以在这个油田中开采 $n$ 个油井。

LQ 公司在这 $n$ 个油井之间修建了 $n-1$ 条道路，每条道路连接两个油井，路径中间不会路过任何油井，而且这些道路将所有油井连通。

建立油井的时候需要使用一台大型设备，运输起来非常麻烦，LQ 公司准备在其中的一个油井位置建立一个空运站，先将设备空运到空运站，之后每次经过他们建立的道路来运输这个大型设备以建立不同的油井，当油井建立完毕后再从空运站将大型设备运走。

为了减少运输的麻烦，公司要求大型设备在道路上运输的总路程是最短的。

在建立油井和采油的过程中需要花费一些人力，第 $i$ 个油井需要花费 $B_i$ 个人，而一旦油井建成，就需要 $S_i$ 个人一直坚守在油井上进行维护。

当然，如果一个人参与了油井的建设，他可以直接留下来维护油井，或者参与下一个油井的建设，但是在维护油井的人不能再参加后续油井的建设了。

现在 LQ 公司想知道，大型设备运输的总路径长度最短是多少？在保证总路径长度最短的情况下，LQ 公司至少需要花费多少人力才能完成所有油井的建立与维护。

## 输入格式

输入的第一行包含一个整数 $n$，表示油井的数量。油井由 $1$ 到 $n$ 依次标号。

第二行包含 $n$ 个整数，依次表示 $B_1,B_2,\cdots,B_n$，相邻的整数之间用一个空格分隔。

第三行包含 $n$ 个整数，依次表示 $S_1,S_2,\cdots,S_n$，相邻的整数之间用一个空格分隔。

接下来 $n-1$ 行描述油井之间的道路，其中的第 $i$ 行包含两个整数 $a$，$b$，用一个空格分隔，表示一条道路的起点为 $i+1$ 、终点为 $a$，长度为 $b$，道路是双向的，设备可以从任意一端运送到另一端，每条道路都可以经过任意多次。数据保证任意两个油井之间都可以通过道路连接。

## 输出格式

输出包含两个整数，用一个空格分隔，表示最优情况下大型设备需要运输的总路程，以及在总路程最短的情况下最少需要花费的人力数量。

## 输入输出样例 #1

### 输入 #1

```
6
3 10 20 7 15 9
2 6 10 4 8 7
1 9
1 2
2 5
3 4
3 7
```

### 输出 #1

```
54 38
```

## 说明/提示

**【样例解释】**

有两种方案达到最优。

方案一：在油井 $2$ 建立空运站，先建立油井 $2$，再将大型设备运输到油井 $1$ 建立油井 $1$，最后将大型设备运回油井 $2$。

方案二：在油井 $1$ 建立空运站，先将大型设备运输到油井 $2$ 建立油井 $2$，再将大型设备运送到油井 $1$ 建立油井 $1$。

**【数据范围】**

对于 $20\%$ 的数据：$n$ 不超过 $10$；

另外 $20\%$ 的数据：每个油井最多和两个油井之间有道路直接连接；

另外 $10\%$ 的数据：有 $n-1$ 个油井只有一条道路与其他油井连接；

对于 $100\%$ 的数据：$1\le n\le10^5$，$B$、$S$、$c$ 均为不超过 $10000$ 的正整数。

时限 1 秒, 256M。蓝桥杯 2018 年第九届国赛

# 题解

#### 贪心 

维护油井的总人数是必须要花费的总人力，设为$ans$

每个节点上的剩余人员$b_i-s_i$可以追加到下一次，所以前面剩余的人员不会浪费，直到最后一次剩余的人才不用，所以，我们对$b_i-s_i$从小到大排序，这样最小的人力花费就是$ans+b_1-s_1$

如果$b_1-s_1$比0小，那么取0，说明建设人数少于维护人数

最后$ans$还要和$mx$比较，如果$ans$不可能比最大的建设人数少

```c++
#include <bits/stdc++.h>
using namespace std;

using i64 = long long;

void solve() {
    int n;
    cin >> n;
    vector<int> a(n), b(n), c(n);
    int mx = 0;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
        mx = max(mx, a[i]);
    }
    int ans = 0;
    for (int i = 0; i < n; i++) {
        cin >> b[i];
        ans += b[i];
        c[i] = a[i] - b[i];
    }
    int len = 0;
    for (int i = 2; i <= n; i++) {
        int x, y;
        cin >> x >> y;
        len += y * 2;
    }
    sort(c.begin(), c.end());
    ans += max(c[0], 0);
    ans = max(ans, mx); 
    cout << len << " " << ans << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int _ = 1;

    // cin >> _;
    while (_--) {
        solve();
    }
    return 0;
}
```

# P1131 [ZJOI2007] 时态同步

## 题目描述

小 Q 在电子工艺实习课上学习焊接电路板。一块电路板由若干个元件组成，我们不妨称之为节点，并将其用数字 $1,2,3\cdots$ 进行标号。电路板的各个节点由若干不相交的导线相连接，且对于电路板的任何两个节点，都存在且仅存在一条通路（通路指连接两个元件的导线序列）。

在电路板上存在一个特殊的元件称为“激发器”。当激发器工作后，产生一个激励电流，通过导线传向每一个它所连接的节点。而中间节点接收到激励电流后，得到信息，并将该激励电流传向与它连接并且尚未接收到激励电流的节点。最终，激励电流将到达一些“终止节点”――接收激励电流之后不再转发的节点。

激励电流在导线上的传播是需要花费时间的，对于每条边 $e$，激励电流通过它需要的时间为 $t_e$，而节点接收到激励电流后的转发可以认为是在瞬间完成的。现在这块电路板要求每一个“终止节点”同时得到激励电路――即保持时态同步。由于当前的构造并不符合时态同步的要求，故需要通过改变连接线的构造。目前小 Q 有一个道具，使用一次该道具，可以使得激励电流通过某条连接导线的时间增加一个单位。请问小 Q 最少使用多少次道具才可使得所有的“终止节点”时态同步？

## 输入格式

第一行包含一个正整数 $N$，表示电路板中节点的个数。

第二行包含一个整数 $S$，为该电路板的激发器的编号。

接下来 $N-1$ 行，每行三个整数 $a,b,t$。表示该条导线连接节点 $a$ 与节点 $b$，且激励电流通过这条导线需要 $t$ 个单位时间。

## 输出格式

仅包含一个整数 $V$，为小 Q 最少使用的道具次数。

## 输入输出样例 #1

### 输入 #1

```
3
1
1 2 1
1 3 3
```

### 输出 #1

```
2
```

## 说明/提示

- 对于 $40\%$ 的数据，$1\le N\le 1000$。
- 对于 $100\%$ 的数据，$1\le N\le 5\times 10^5$。

对于所有的数据，$1\le t_e\le 10^6$。

# 题解

用$dis[x]$记录子树$x$的根到其叶子节点的最大距离

遍历每棵子树时，更新儿子$y$到$x$的距离，$dis[x]=max(dis[x],dis[y]+w[x,y])$

最后一次回溯到$x$后，依次枚举$x$的儿子，累计短缺的距离，$ans+=dis[x]-(dis[y]+w(x,y))$

遍历完即得到答案$ans$

```c++
#include <bits/stdc++.h>
using namespace std;

using i64 = long long;

struct Edge {
    int to, ne, w;
};

void solve() {
    int n, rt;
    cin >> n >> rt;
    vector<Edge> e(n * 2 + 1);
    vector<int> h(n + 1);
    int cur = 0;
    auto add = [&](int u, int v, int w) {
        e[++cur] = {v, h[u], w};
        h[u] = cur;
    };
    for (int i = 1; i < n; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        add(u, v, w);
        add(v, u, w);
    }
    i64 ans = 0;
    vector<i64> dis(n + 1);
    auto dfs = [&](auto &&self, int u, int fa) -> void {
        for (int i = h[u]; i; i = e[i].ne) {
            int v = e[i].to;
            if (v == fa) {
                continue;
            }
            self(self, v, u);
            dis[u] = max(dis[u], dis[v] + e[i].w);//u子树到叶子节点的最大距离
        }
        for (int i = h[u]; i; i = e[i].ne) {//依次枚举u的儿子累计短缺距离
            int v = e[i].to;
            if (v == fa) {
                continue;
            }
            ans += dis[u] - (dis[v] + e[i].w);
        }
    };
    dfs(dfs, rt, 0);
    cout << ans << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int _ = 1;

    // cin >> _;
    while (_--) {
        solve();
    }
    return 0;
}
```







