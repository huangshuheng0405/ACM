# 混合背包

###### 将01背包，完全背包，多重背包混合起来，有的只能取一次，有的能取无限次，有的只能取k次，

# 樱花

## 题目背景

《爱与愁的故事第四弹·plant》第一章。

## 题目描述

爱与愁大神后院里种了 $n$ 棵樱花树，每棵都有美学值 $C_i(0 \le C_i \le 200)$。爱与愁大神在每天上学前都会来赏花。爱与愁大神可是生物学霸，他懂得如何欣赏樱花：一种樱花树看一遍过，一种樱花树最多看 $P_i(0 \le P_i \le 100)$ 遍，一种樱花树可以看无数遍。但是看每棵樱花树都有一定的时间 $T_i(0 \le T_i \le 100)$。爱与愁大神离去上学的时间只剩下一小会儿了。求解看哪几棵樱花树能使美学值最高且爱与愁大神能准时（或提早）去上学。

## 输入格式

共 $n+1$行：

第 $1$ 行：现在时间 $T_s$（几时：几分），去上学的时间 $T_e$（几时：几分），爱与愁大神院子里有几棵樱花树 $n$。这里的 $T_s$，$T_e$ 格式为：`hh:mm`，其中 $0 \leq hh \leq 23$，$0 \leq mm \leq 59$，且 $hh,mm,n$ 均为正整数。

第 $2$ 行到第 $n+1$ 行，每行三个正整数：看完第 $i$ 棵树的耗费时间 $T_i$，第 $i$ 棵树的美学值 $C_i$，看第 $i$ 棵树的次数 $P_i$（$P_i=0$ 表示无数次，$P_i$ 是其他数字表示最多可看的次数 $P_i$）。

## 输出格式

只有一个整数，表示最大美学值。

## 样例 #1

### 样例输入 #1

```
6:50 7:00 3
2 1 0
3 3 1
4 5 4
```

### 样例输出 #1

```
11
```

## 提示

$100\%$ 数据：$T_e-T_s \leq 1000$（即开始时间距离结束时间不超过 $1000$ 分钟），$n \leq 10000$。保证 $T_e,T_s$ 为同一天内的时间。

样例解释：赏第一棵樱花树一次，赏第三棵樱花树 $2$ 次。

# 思路

利用二进制优化把多重背包转化为01背包

```c++
#include <bits/stdc++.h>
using namespace std;

using i64 = long long;

int vol[10005], val[10005], v[100005], w[100005], dp[1005], p[10005];

void solve() {
    int a, b, c, d, n;
    char e;
    cin >> a >> e >> b >> c >> e >> d >> n;

    int m = (c - a) * 60 + (d - b);
    for (int i = 1; i <= n; i++) {
        cin >> vol[i] >> val[i] >> p[i];

        if (p[i] == 0) {
            p[i] = 999999; // 把能取无穷次假设为取的次数很大
        }
    }

    int cnt = 0;
    for (int i = 1; i <= n; i++) { // 二进制优化
        int k = 1;
        while (k <= p[i]) {
            v[++cnt] = k * val[i];
            w[cnt] = k * vol[i];
            p[i] -= k;
            k *= 2;
        }

        if (p[i]) {
            v[++cnt] = p[i] * val[i];
            w[cnt] = p[i] * vol[i];
        }
    }

    for (int i = 1; i <= cnt; i++) { // 01背包
        for (int j = m; j >= w[i]; j--) {
            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
        }
    }

    cout << dp[m] << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int _ = 1;

    // cin >> _;
    while (_--) {
        solve();
    }
    return 0;
}
```

