

# 前缀函数

> 真后缀和真前缀都是除了自己本身的后缀、前缀

## 定义

给定一个长度为$n$的字符串$s$,其前缀函数被定义为一个长度为$n$的数组$\pi$。其中$\pi[i]$的定义：

1.如果子串有一对相等的真前缀与真后缀，那么$\pi[i]$就是这个相等的真前缀的长度

2.如果不止有一队相等的，那么长度取最长的那一对的长度

3.如果没有相等的，那么$\pi[i]=0$

简单来说$\pi [i]$就是，子串$s[0\dots i]$最长的相等的真前缀与真后缀的长度

特别的，规定$\pi [0]=0$

## 过程

举例来说，对于字符串 `abcabcd`，

$\pi [0] = 0$，因为 `a` 没有真前缀和真后缀，根据规定为 0

$\pi [1]=1$，因为 `ab` 无相等的真前缀和真后缀

$\pi [2]=0$，因为 `abc` 无相等的真前缀和真后缀

$\pi [3]= 1$，因为 `abca` 只有一对相等的真前缀和真后缀：`a`，长度为 1

$\pi[4]=2$，因为 `abcab` 相等的真前缀和真后缀只有 `ab`，长度为 2

$\pi[5]=3$，因为 `abcabc` 相等的真前缀和真后缀只有 `abc`，长度为 3

$\pi[6]=0$，因为 `abcabcd` 无相等的真前缀和真后缀

同理可以计算字符串 `aabaaab` 的前缀函数为$[0,1,0,1,2,2,3]$。

时间复杂度$O(n)$

# KMP

在字符串中查找字串：Knuth-Morris-Pratt算法

# 【模板】KMP

## 题目描述

给出两个字符串 $s_1$ 和 $s_2$，若 $s_1$ 的区间 $[l, r]$ 子串与 $s_2$ 完全相同，则称 $s_2$ 在 $s_1$ 中出现了，其出现位置为 $l$。  
现在请你求出 $s_2$ 在 $s_1$ 中所有出现的位置。

定义一个字符串 $s$ 的 border 为 $s$ 的一个**非 $s$ 本身**的子串 $t$，满足 $t$ 既是 $s$ 的前缀，又是 $s$ 的后缀。  
对于 $s_2$，你还需要求出对于其每个前缀 $s'$ 的最长 border $t'$ 的长度。

## 输入格式

第一行为一个字符串，即为 $s_1$。  
第二行为一个字符串，即为 $s_2$。

## 输出格式

首先输出若干行，每行一个整数，**按从小到大的顺序**输出 $s_2$ 在 $s_1$ 中出现的位置。  
最后一行输出 $|s_2|$ 个整数，第 $i$ 个整数表示 $s_2$ 的长度为 $i$ 的前缀的最长 border 长度。

## 样例 #1

### 样例输入 #1

```
ABABABC
ABA
```

### 样例输出 #1

```
1
3
0 0 1
```

## 提示

### 样例 1 解释

 ![](https://cdn.luogu.com.cn/upload/pic/2257.png)。

对于 $s_2$ 长度为 $3$ 的前缀 `ABA`，字符串 `A` 既是其后缀也是其前缀，且是最长的，因此最长 border 长度为 $1$。


### 数据规模与约定

**本题采用多测试点捆绑测试，共有 3 个子任务**。

- Subtask 1（30 points）：$|s_1| \leq 15$，$|s_2| \leq 5$。
- Subtask 2（40 points）：$|s_1| \leq 10^4$，$|s_2| \leq 10^2$。
- Subtask 3（30 points）：无特殊约定。

对于全部的测试点，保证 $1 \leq |s_1|,|s_2| \leq 10^6$，$s_1, s_2$ 中均只含大写英文字母。

# 题解

预处理前缀函数

```c++
#include <bits/stdc++.h>
using namespace std;

using i64 = long long;

void solve() {
    string s, t;
    cin >> s >> t;
    auto kmp = [&](string s, string t) {
        int n = s.size(), m = t.size();
        vector<int> nex(m + 1);// 前缀函数
        s = '-' + s;
        t = '-' + t;
        for (int i = 2, j = 0; i <= m; i++) {// 求t的前缀函数
            while (j && t[i] != t[j + 1]) {
                j = nex[j];
            }
            if (t[i] == t[j + 1]) {
                j++;
            }
            nex[i] = j;
        }
        for (int i = 1, j = 0; i <= n; i++) {
            while (j && s[i] != t[j + 1]) {
                j = nex[j];
            }
            if (s[i] == t[j + 1]) {
                j++;
            }
            if (j == m) {
                cout << i - m + 1 << "\n"; // t在s中出现的位置
                j = nex[j];
            }
        }
        for (int i = 1; i <= m; i++) {
            cout << nex[i] << " ";
        }
    };
    kmp(s, t);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    int _ = 1;

    // cin >> _;
    while (_--) {
        solve();
    }
    return 0;
}
```

